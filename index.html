<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>ASSIST a MAQAO module | ASSIST</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="ASSIST page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Automatic Source-to-Source assISTant" />
<meta property="og:description" content="Automatic Source-to-Source assISTant" />
<link rel="canonical" href="https://youelebr.github.io/index.html" />
<meta property="og:url" content="https://youelebr.github.io/index.html" />
<meta property="og:site_name" content="ASSIST" />
<script type="application/ld+json">
{"headline":"ASSIST","@type":"WebPage","url":"https://youelebr.github.io/index.html","description":"Automatic Source-to-Source assISTant","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">ASSIST</h1>
      <h2 class="project-tagline">Automatic Source-to-Source assISTant</h2>
      
        <a href="https://github.com/youelebr" class="btn">View on GitHub</a>
      
      
    </section>

     <section class="main-content">
      <hr />
<p><a href="index.html">Home</a> - 
<a href="dissemination.html">Dissemination</a> -  
<a href="documentation.html">Documentation</a> - 
<a href="gettingstarted.html">Getting Started</a> -
<a href="tutorials.html">Tutorials</a> -
<a href="https://maqaoteam.github.io/MAQAO/">MAQAO</a> -
<a href="https://maqaoteam.github.io/MAQAO/team.html">MAQAO Team</a> </p>

<hr />

<h1 id="outline">Outline</h1>

<p><a href="#instroduction">Instroduction</a> <br />
<a href="#context">Context</a> <br />
<a href="#what-is-ASSIST">What Is ASSIST</a> <br />
<a href="#documentation">Documentation</a></p>

<h1 id="instroduction">Instroduction</h1>

<p>This page gives an overview of the ASSIST module and contains links to the pages explaining behaviour, options, algorithms, code layout(s), descriptions of inputs and outputs, tutorials, etc. </p>

<p>
The purpose of ASSIST (Automatic Source-to-Source assISTant) is to provide a semi automatic tool to perform source-to-source transformations to optimize performances. 
Our framework ASSIST is based on the Rose Compiler Framework Project and uses its API to read and modify the Abstract Syntax Tree (AST) generated by Rose’s compiler frontends. 
It's currently a semi automatic tool because it requires the intervention of the user, he can write some directive in his source code to guide the transformations or directly feed ASSIST with results from some MAQAO modules like Oneview, CQA,or VPROF.

ASSIST allows to easily performing complex modifications in order to carry out:
</p>

<ul>
  <li>Performance optimization</li>
  <li>General program transformation</li>
  <li>Instrumentation</li>
  <li>Perform optimizations using MAQAO analyses</li>
</ul>

<h2 id="context"> Context </h2>
<p>Traditionally users try to change their source code according to the metrics and sometimes hints reported by performance evaluation tools. 
	The source code may end up bloated by tricky transformations (e.g. tiling), special cases or even useless modifications. 
	That's even worse if you need to handle multiple architectures (e.g. x86 and GPU or ARM). 
	A much natural way would be to describe the foreseen (optimization) transformations, on an architecture basis if needed, and not overload the source code more than it may already be.
	There are many ways to implement this approach; from a regular application developer point of view, annotating the code with directives provide the best compromise between expressiveness and complexity. 
	Be able to express transformations is not sufficient, there is a need for hints that will guide the selection of these transformations. 
	That's where feedback data optimization (FDO) comes into play, one example of FDO Tool is the FDO modes embedded with production compilers (Intel, GNU or LLVM) which names pgo and autofdo. 
	Compilers’ FDO tools instrument the binary to collect and profile the execution before to use these feedbacks data during the compilation process to produce a new version that is supposed to be more efficient for that run.
	Exascale Computing Research lab develop MAQAO (Modular Assembly Quality Analyzer and Optimizer), a framework for binary code analysis and optimization automation. 
	MAQAO is modular and is capable of supporting a large number of target architectures. MAQAO provides multiple analysis tools which can return useful information about how to optimize codes. 
	Currently, MAQAO analyzers require more or less knowledge of low level programming constructs and computer architecture to optimize codes efficiently using these results.
	In this document, we present ASSIST (Automatic Source-to-Source assISTant), a MAQAO module that can optimize source codes by analyzing and modifying source codes automatically with little interaction from the user. 
	ASSIST can either be fed by MAQAO’s modules output or, if users know how to optimize their code or simply wants to automate certain repetitive and human-error-prone tasks, they can use directives and our tool will apply associated transformations. 
	The source-to-source was chosen in order to produce the most portable optimized source code possible. 
</p>


<h2 id="what-is-ASSIST">What Is ASSIST</h2>
<p>ASSIST is an open source project developed as part of my PhD thesis at Exascale Computing Research Lab as a prototype. 
	ASSIST aimed at scientists and engineers searching to optimize their HPC applications’ performance without having to delve into the details of the whole process. 
	The tool is able to read analyses provided by MAQAO modules (e.g. VPROF) or optimization recommendations from CQA, and applies the transformations recommend by these modules to optimize the target codes. 
	If users are aware of the kind of optimization they want, ASSIST is also able to read custom directives in the code and apply associated transformations.
	Our tool can handle multiple source languages (C/C++/Fortran) and is based on the Rose Compiler Project. 
	The next section will present how to install and use ASSIST. 
	Section 3 presents a description of all implemented transformations is provided and how to use them with directives.
	Section 4 presents an example with the application ABINIT. 
	We finish in section 5 and 6 with a discussion around the caveats and limitations and a F.A.Q. 
</p>


<h2 id="tool-architecture">Tool Architecture</h2>
In this section, we will describe the architecture of our tool and why did we make these choices.

<h4> Rose &amp; Frontend </h4>
Among all existing frameworks that can perform source-to-source transformations, we searched one with a non-commercial license to keep our project open source. Moreover, most of HPC applications are written in Fortran, C or C++, so we also searched for a tool able to handle these three languages. Table1 presents a non-exhaustive list of the tools which met our criteria.
<br /> <br />
[Comparative Table] Table 1: Comparative array of tools performing source-to-source
<br /> <br />

Of all existing frameworks, we managed to test the following: Cetus, Par4All, PIPS, Clang, Noise, Rose. Some of these frameworks did not meet the second criterion cited previously, only Clang (Flang will come out soon to handle the Fortran language) and Rose fit our requirements. Clang was a good candidate for our project with the use of a large library to manipulate the AST but, if the modification of a node can be without difficulty, adding a new node is less trivial given that Clang was not designed for modifying the AST rather analyzing it. On the other hand, Rose, was created to make source-to-source transformations. A full API is available to manipulate the AST and handle Fortran, C, C++ along with other languages.

With these elements at hand, we based ASSIST on the Rose Compiler Framework Project in order to manipulate the target application’s AST. Rose is developed and maintained by the Lawrence Livermore National Laboratory and available at <a href="http://rosecompiler.org/">http://rosecompiler.org/</a>.

<h4>Rose Upgrade</h4>

In order to handle Fortran, Rose uses a frontend named OpenFortranParser (OFP); it is a project which provides ANTLR-based parsing tools that support Fortran. Soon after starting to work with Fortran codes, we realized there are myriads of limitations to the way Rose and OFP handle Fortran.
<br /> <br />
First, there is no management of directives and comments. When a comment or a directive is present in a code, it ignored and therefore not present in the AST. This constraint meant that the output of the rewrite process will lack vital information. This led us to modifying Rose by adding a way to handle all Fortran comments, and then consider directives as a special comment.
<br /> <br />
Similarly, C pre-processor directives (i.e. “#ifdef”), were not taken into account. The previous modification meant that they are considered a comment losing therefore their directive properties. Adding C directives with all their characteristics to Rose would take a lot of time, and we chose to rather focus on transformations.
<br /> <br />
Rose handle Fortran up to the 2003 standard. All keywords and features added in Fortran20008 are not handled. As C directives, adding Fortran2008 keywords represent a lot of work, so we add a way in our framework to go beyond. In our partner’s codes when a Fortran2008 feature is used it is surrounded by C directives “#ifdef FORTRAN2008” and we add the compiler option (“-f2008”) which will comment all statement between the “#ifdef” and the “#else” and uncomment after the transformation.
<br /> <br />
We also encounter problems in the rewriting mechanism; some spaces are skipped or keywords at some locations in the output file. Therefore, we modified some functions to improve Fortran files and return a file as close as possible to the input when no modifications were operated.
Pragma approach or external configure file
<br /> <br />
A directive is a statement that specifies how a compiler should process its input. They are available for Fortran and C/C++, and the legacy code still can be executed while the application behavior is unchanged if the compiler does not recognize the directive. The chosen approach is similar to the one used by the widely available parallelization standard – OpenMP. Thus, the application source code was kept portable and a non-optimized binary version can be built using any compiler. This mode is the most usually used, users can complete profiler results by adding a transformation of their choice.
<br /> <br />
When users cannot modify the source code, we offer the possibility to write a configuration file with the description of each statement they want transformed. The configuration file looks as follow: &lt;Example of configuration file&gt;

<h4>MAQAO Integration</h4>

Once the AST manipulation framework was chosen and a translator designed with basic transformations – described in the next section – we integrated our work to MAQAO as a module. On the basis of the Rose framework, we designed a whole API with a loop abstraction and functions for programmers wishing to design optimizations or analysis with our tool.
<br /> <br />
The first one is to use the output of others MAQAO modules. Currently ASSIST can read results from VPROF, CQA and LPROF, but can only use the VPROF output to apply the loop count transformation using the number of iterations of a loop that VPROF has analyzed; the use of the results of the other modules is on the way. ASSIST reads CSV format as an input, then analyzes the results and searches for the corresponding loop to attach the “LOOP COUNT” directive available with ICC. This directive helps indicate to the compiler the minimum (e.g. maximum and average) number of iterations of the loop. The compiler will be able to optimize the loop using this information.



<h1 id="documentation">Documentation</h1>
      <footer class="site-footer">
          <span class="site-footer-owner"><a href="https://github.com/MaqaoTeam/MAQAO">MAQAO</a> is maintained by <a href="https://github.com/MaqaoTeam">MaqaoTeam</a>.</span>
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>
  </body>
</html>
